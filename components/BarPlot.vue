<template>
  <div>
    <b-row>
      <b-col cols="8">
        <div class="butns">
          <!-- Buttons -->
          <b-button-group class="ml-auto">
            <!-- Button Sort -->
            <b-button squared variant="outline-secondary" v-if="sortOrder === 'raw'" @click="toggleSortOrder"
              :disabled="loading">
              Sort & Classify Data
            </b-button>
            <b-button squared variant="outline-secondary" v-else @click="toggleSortOrder" :disabled="loading">
              Return To Raw Results
            </b-button>
            <!-- Button Optimal -->
            <b-button squared variant="outline-secondary" v-if="optimal === 'no'" :disabled="loading"
              @click="optimalView">
              Optimal View
            </b-button>
            <b-button squared variant="outline-secondary" v-else :disabled="loading" @click="optimalView">
              Reset View
            </b-button>
            <!-- Button Download -->
            <b-dropdown variant="outline-secondary" right text="Download" :disabled="loading">
              <b-dropdown-header id="dropdown-header-label">Select a format</b-dropdown-header>
              <b-dropdown-item @click="downloadChart('png')">PNG</b-dropdown-item>
              <b-dropdown-item @click="downloadChart('svg')">SVG (only plot)</b-dropdown-item>
              <b-dropdown-divider></b-dropdown-divider>
              <b-dropdown-item @click="downloadChart('pdf')">PDF</b-dropdown-item>
            </b-dropdown>
          </b-button-group>
        </div>
      </b-col>
    </b-row>
    <div id="todownload">
      <b-row class="mt-4">
        <!-- Chart -->
        <b-col cols="8">
          <div id="barPlot"></div>
        </b-col>

        <!-- Quartile Table -->
        <b-col cols="4">
          <div :class="{ 'table-container': true, 'fade-in': sortOrder === 'sorted', 'fade-out': sortOrder === 'raw' }">
            <table class="table table-fixed table-bordered  quartile-table-container" id='quartileTable'>
              <thead>
                <tr>
                  <th style="width: 60%;" class="table-secondary">Tool</th>
                  <th style="width: 40%;" class="table-secondary">Quartile <font-awesome-icon id="extrainfoquartile"
                      :icon="['fas', 'question']" style="color: #ffffff;  float: right; margin-left: 5px;margin-top: 3px;" /></th>
                  <b-popover target="extrainfoquartile" triggers="hover" placement="bottom">
                    <template #title><b>How to</b></template>

                   By default, the highest values will be displayed in the first quartile.
                    Inversely if it is specified.
                  </b-popover>
                </tr>
              </thead>
              <tbody>
                <tr v-for="(quartile, index) in quartileDataArray" :key="index">
                  <td>{{ quartile.tool }}</td>
                  <td :style="{ backgroundColor: quartile.quartile.bgColor }">{{ quartile.quartile.quartile }}
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </b-col>
      </b-row>

      <!-- Row for the paragraph -->
      <b-row class="mt-4">
        <!-- Column for the ID table -->
        <b-col cols="8">
          <!-- ID AND DATE TABLE -->
          <div v-if="datasetId && formattedDate" class="tableid">
            <table class=" table table-bordered rounded-3" id='idDateTable'>
              <tbody>
                <tr>
                  <th>Dataset ID</th>
                  <td>{{ datasetId }}</td>
                  <th>Last Update</th>
                  <td>{{ formattedDate }}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </b-col>

      </b-row>
    </div>
  </div>
</template>

<script setup>
import { onBeforeMount, ref, watch } from 'vue';
import { computed } from 'vue';


const html2canvas = require('html2canvas');
const { jsPDF } = require('jspdf');

import 'jspdf-autotable';

// DATA RETRIEVE
const props = defineProps(['jsonData'])


const loading = ref(false);
const dataset = ref(null);
const originalData = ref(null);
const datasetId = ref(null);
const datasetDate = ref(null);
const datasetPolarity = ref(null);
const formattedDate = ref(null);
const sortOrder = ref('raw');
const optimal = ref('no');
const quartileData = ref({});
const quartileDataArray = computed(() => {
  // Convert quartileData object into an array of objects
  const array = Object.entries(quartileData.value).map(([tool, quartile]) => ({ tool, quartile }));
  // Sort the array alphabetically
  return array.sort((a, b) => a.tool.localeCompare(b.tool));
});

const showAdditionalTable = ref(false);

// ----------------------------------------------------------------
// CREATE PLOT
// ----------------------------------------------------------------
onBeforeMount(async () => {
  const Plotly = require('plotly.js-dist');
  loading.value = true;

  // Dataset values
  dataset.value = await props.jsonData
  const data = dataset.value.datalink.inline_data;

  const visualization = data.visualization
  datasetId.value = dataset.value._id;
  datasetDate.value = dataset.value.dates.modification;
  datasetPolarity.value = dataset.value.datalink.inline_data.visualization.better;
  formattedDate.value = formatDateString(datasetDate.value); // Format the date

  // Save original data for future use
  originalData.value = data;

  // Calculate maximum value for y-axis range
  const maxMetricValue = Math.max(...data.challenge_participants.map(entry => entry.metric_value));

  const x = data.challenge_participants.map(entry => entry.tool_id);
  const y = data.challenge_participants.map(() => 0);

  const colors = Array(x.length).fill('#0b579f'); // Initial colors


  const initialTrace = {
    x,
    y,
    type: 'bar',
    marker: {
      color: colors,
    },
  };


  const layout = {
    title: '',
    autosize: true,
    height: 800,
    xaxis: {
      title: {
        text: 'TOOLS',
        standoff: 30,
        font: {
          family: 'Arial, sans-serif',
          size: 18,
          color: 'black',
          weight: 'bold',
        },
      },
      fixedrange: true,
      tickangle: -45,
      tickfont: { size: 12 },
    },
    yaxis: {
      title: {
        text: visualization.metric,
        font: {
          family: 'Arial, sans-serif',
          size: 18,
          color: 'black',
          weight: 'bold',
        },
      },
      fixedrange: true,
      range: [0, maxMetricValue + 0.1],
    },
    margin: { l: 50, r: 50, t: 100, b: 110, pad: 4 },
    images: [
      {
        source: "/2018.OpenEBench.logo.Manual_page2.png",
        xref: "paper",
        yref: "paper",
        x: 0.95,
        y: 1.17,
        sizex: 0.1,
        sizey: 0.3,
        xanchor: "right",
        yanchor: "top",
        opacity: 0.5,
      }
    ],
  };

  const config = {
    displayModeBar: false,
    responsive: true,
    hovermode: false
  }

  // Create the bar chart with the initial trace and layout
  Plotly.newPlot('barPlot', [initialTrace], layout, config);


  const myPlot = document.getElementById('barPlot');

  // Change the color of tghe bars on hover.
  myPlot.on('plotly_hover', function (event) {
    const pn = event.points[0].pointNumber;
    const hoverColors = Array(x.length).fill('#0b579f'); // Reset colors
    hoverColors[pn] = '#f47c21'; // Change color on hover (you can adjust the color)

    const update = { 'marker': { color: hoverColors } };
    Plotly.restyle('barPlot', update);
  });

  myPlot.on('plotly_unhover', function () {
    const unhoverColors = Array(x.length).fill('#0b579f'); // Reset colors

    const update = { 'marker': { color: unhoverColors } };
    Plotly.restyle('barPlot', update);
  });

  // Simulate fetching data with animation
  setTimeout(() => {
    const actualTrace = {
      y: data.challenge_participants.map(entry => entry.metric_value),
    };

    // Animate the transition from 0 to actual values
    Plotly.animate('barPlot', {
      data: [actualTrace],
      traces: [0],
      transition: {
        duration: 1000,
        easing: 'ease-in-out',
      },
    });
    loading.value = false;

  }, 500);


  // Set up of the cursor inside the plot. Set default.
  // Select all SVG rect elements with class 'cursor-pointer' within the chart container
  const chartContainer = document.getElementById('barPlot');
  // Add a mouseover event listener to the chart container
  chartContainer.addEventListener('mouseover', function (event) {
    // Check if the mouseover event is triggered by a cursor-pointer element
    if (event.target.classList.contains('cursor-pointer')) {
      // Prevent the default behavior of the mouseover event
      event.preventDefault();
      // Set the cursor style to 'default' directly on the target element
      event.target.style.cursor = 'default';
    }
  });

})

// ----------------------------------------------------------------
// FUNCTIONS
// ----------------------------------------------------------------
// ANIMATIONS
// ----------------------------------------------------------------

function animateBars(data) {
  const Plotly = require('plotly.js-dist');
  const x = data.map(entry => entry.tool_id);
  const y = data.map(() => 0); // Start with all bars at 0

  const update = {
    x: [x],
    y: [y],
  };

  Plotly.update('barPlot', update);

  const actualTrace = {
    y: data.map(entry => entry.metric_value),
  };

  // Animate the transition from 0 to actual values
  Plotly.animate('barPlot', {
    data: [actualTrace],
    traces: [0],
    transition: {
      duration: 1000,
      easing: 'ease-in-out',
    },
  });
}

function animateLine(shapeIndex) {
  const Plotly = require('plotly.js-dist');
  const layout = document.getElementById('barPlot').layout;
  const shape = layout.shapes[shapeIndex];
  const yTarget = 1; // End at the top

  let y = 0; // Start from the bottom

  const animateStep = () => {
    if (y <= yTarget) {
      // Update the y-coordinate of the line shape
      shape.y1 = y;

      // Update the layout with the modified shape
      Plotly.relayout('barPlot', { shapes: layout.shapes });

      // Increment y and trigger the next animation step
      y += 0.03; // Adjust the speed as needed
      requestAnimationFrame(animateStep);
    }
  };

  // Start the animation
  animateStep();
}


// BUTTON OPTIMAL VIEW
// ----------------------------------------------------------------
async function optimalView() {
  try {
    if (optimal.value === 'no') {
      const Plotly = require('plotly.js-dist');

      // Fetch current data and calculate metric range
      let data;
      if (sortOrder.value !== 'raw') {
        // If data has been sorted, use the sorted data
        data = originalData.value.challenge_participants.slice().sort((a, b) => b.metric_value - a.metric_value);
      } else {
        // Otherwise, use the original data
        data = originalData.value.challenge_participants;
      }

      const metricValues = data.map(entry => entry.metric_value);
      const minMetric = Math.min(...metricValues);
      const maxMetric = Math.max(...metricValues);

      // Calculate range between min and max metrics
      const metricRange = maxMetric - minMetric;

      // Calculate new y-axis range with a slight buffer based on metric range
      const minY = Math.max(0, minMetric - metricRange * 0.2);
      const maxY = maxMetric + metricRange * 0.08;

      // Update plot layout with new y-axis range
      Plotly.relayout('barPlot', { 'yaxis.range': [minY, maxY] });

      // Animate the bars
      animateBars(data);

      // Update optimal value to indicate optimal view is active
      optimal.value = 'yes';
    } else {
      const Plotly = require('plotly.js-dist');
      let data;
      if (sortOrder.value !== 'raw') {
        // If data has been sorted, use the sorted data
        data = originalData.value.challenge_participants.slice().sort((a, b) => b.metric_value - a.metric_value);
      } else {
        // Otherwise, use the original data
        data = originalData.value.challenge_participants;
      }
      // Return to original data view by restoring the original y-axis range
      const originalLayout = {
        'yaxis.range': [0, Math.max(...data.map(entry => entry.metric_value)) + 0.1]
      };

      // Update plot layout with original y-axis range
      Plotly.relayout('barPlot', originalLayout);

      // Animate the bars after adjusting the y-axis range
      animateBars(data);

      // Update optimal value to indicate original view is active
      optimal.value = 'no';
    }
  } catch (error) {
    console.error('Error in optimalView:', error);
  }
}



// BUTTON SORT & CLASSIFY
// ----------------------------------------------------------------
async function toggleSortOrder() {
  try {
    if (sortOrder.value === 'raw') {
      showAdditionalTable.value = !showAdditionalTable.value;
      // Sort logic (descending order)
      const sortedData = originalData.value.challenge_participants.slice().sort((a, b) => b.metric_value - a.metric_value);

      updateChart(sortedData);
      // Call the animateBars function after updating the chart
      animateBars(sortedData);
      // Calculate quartiles and update the table data
      quartileData.value = calculateQuartiles(sortedData);

      // Add lines between quartile groups
      addLinesBetweenQuartiles();

      // Add quartile labels
      addQuartileLabels();

    } else {
      // Return to raw data
      updateChart(originalData.value.challenge_participants);
      // Call the animateBars function after updating the chart
      animateBars(originalData.value.challenge_participants);
      quartileData.value = {};

      // Remove lines between quartile groups
      removeLinesBetweenQuartiles();

      // Clear quartile labels
      clearQuartileLabels();
    }

    // Toggle sortOrder
    sortOrder.value = sortOrder.value === 'raw' ? 'sorted' : 'raw';
  } catch (error) {
    console.error('Error in toggleSortOrder:', error);
  }
}


// PLOT LAYOUT
// ----------------------------------------------------------------
function addLinesBetweenQuartiles() {
  const Plotly = require('plotly.js-dist');
  const layout = document.getElementById('barPlot').layout;

  // Ensure layout.shapes is initialized as an array
  layout.shapes = layout.shapes || [];

  const tools = Object.keys(quartileData.value);

  // Iterate over the tools to find transitions between quartiles
  for (let i = 1; i < tools.length; i++) {
    const currentTool = quartileData.value[tools[i]];
    const previousTool = quartileData.value[tools[i - 1]];

    // If the quartile of the current tool is different from the previous tool, draw a line between them
    if (currentTool.quartile !== previousTool.quartile) {
      // Calculate the x-position for the line between the current and previous tools
      const linePosition = (i + i - 1) / 2;

      // Add a line shape to the layout with initial y-positions at the bottom
      layout.shapes.push({
        type: 'line',
        xref: 'x',
        yref: 'paper',
        x0: linePosition,
        x1: linePosition,
        y0: 0,  // Start from the bottom
        y1: 0,  // Start from the bottom
        line: {
          color: 'rgba(11, 87, 159, 0.5)',
          width: 1,
          dash: 'dashdot'
        }
      });

      // Animate the line upwards to its final position
      animateLine(layout.shapes.length - 1);
    }
  }

  // Update the layout with the new shapes
  Plotly.relayout('barPlot', { shapes: layout.shapes });
}


function removeLinesBetweenQuartiles() {
  const Plotly = require('plotly.js-dist');
  const layout = document.getElementById('barPlot').layout;

  // Remove existing shapes
  layout.shapes = layout.shapes.filter(shape => shape.type !== 'line');

  // Update the plotly layout
  Plotly.update('barPlot', {}, layout);
}



function addQuartileLabels() {
  const Plotly = require('plotly.js-dist');
  const layout = document.getElementById('barPlot').layout;

  // Ensure layout.annotations is initialized as an array
  layout.annotations = layout.annotations || [];

  const tools = Object.keys(quartileData.value);
  const quartileCounts = {}; // Object to store the count of quartiles for each quartile number
  let uniqueQuartiles = []; // Array to store quartiles with only one tool

  // Count the occurrences of each quartile number
  tools.forEach(tool => {
    const quartile = quartileData.value[tool].quartile;
    quartileCounts[quartile] = (quartileCounts[quartile] || 0) + 1;
  });

  // Identify quartiles with only one tool
  uniqueQuartiles = Object.keys(quartileCounts).filter(quartile => quartileCounts[quartile] === 1);

  // Set to keep track of added label positions
  const addedLabelPositions = new Set();

  // Iterate over the tools to add quartile labels
  tools.forEach(tool => {
    const quartile = quartileData.value[tool].quartile;

    // Calculate the label position based on quartile count
    let labelPosition;
    if (quartileCounts[quartile] === 1) {
      // If quartile occurs only once, place the label above the tool
      labelPosition = tools.indexOf(tool);
    } else {
      // If quartile occurs multiple times, calculate the midpoint between tools with the same quartile
      const positions = tools.reduce((acc, curr, index) => {
        if (quartileData.value[curr].quartile === quartile) {
          acc.push(index);
        }
        return acc;
      }, []);

      const sum = positions.reduce((sum, pos) => sum + pos, 0);
      labelPosition = sum / positions.length;
    }

    // Add label only if it hasn't been added at this position
    if (!addedLabelPositions.has(labelPosition)) {
      // Add a label annotation to the layout
      layout.annotations.push({
        x: labelPosition,
        y: 1.03, // Top of the chart
        xref: 'x',
        yref: 'paper',
        text: `Q${quartile}`,
        showarrow: false,
        font: {
          size: 16,
          color: 'rgba(11, 87, 159, 0.5)'
        }
      });

      // Add the label position to the set of added positions
      addedLabelPositions.add(labelPosition);
    }
  });

  // Update the layout with the new annotations
  Plotly.relayout('barPlot', { annotations: layout.annotations });
}



function clearQuartileLabels() {
  const Plotly = require('plotly.js-dist');
  const layout = document.getElementById('barPlot').layout;

  // Ensure layout.annotations is initialized as an array
  layout.annotations = [];

  // Update the layout with the cleared annotations
  Plotly.relayout('barPlot', { annotations: layout.annotations });
}



function updateChart(data) {
  const Plotly = require('plotly.js-dist');
  const x = data.map(entry => entry.tool_id);
  const y = data.map(entry => entry.metric_value);

  const update = {
    x: [x],
    y: [y],
  };

  Plotly.update('barPlot', update);
}

// CALCULATE QUARTILES
// ----------------------------------------------------------------
// Function to calculate medians in odd or even arrays.
function calculateMedians(inputArray) {
  const sortedArray = [...inputArray].sort((a, b) => a - b);

  // Median number
  const middleIndex = Math.floor(sortedArray.length / 2);

  if (inputArray.length % 2 === 0) {
    // Even length
    const middleValues = [sortedArray[middleIndex - 1], sortedArray[middleIndex]];
    return (middleValues[0] + middleValues[1]) / 2;
  } else {
    // Odd length
    return sortedArray[middleIndex];
  }
}

function calculateQuartiles(data) {
  const sortedValues = data.map(entry => entry.metric_value).sort((a, b) => a - b);
  const middleIndex = Math.floor(data.length / 2);

  let q1, q2, q3;
  // Calculate Q2
  if (sortedValues.length % 2 === 0) {
    // Even length
    q2 = (sortedValues[middleIndex - 1] + sortedValues[middleIndex]) / 2;
  } else {
    // Odd length
    q2 = sortedValues[middleIndex];
  }

  const lowerArray = sortedValues.filter(value => value < q2);
  const upperArray = sortedValues.filter(value => value > q2);

  // Calculate median for lowerArray and upperArray
  q1 = calculateMedians(lowerArray);
  q3 = calculateMedians(upperArray);

  // Create an object to store metric positions
  const metricPositions = {};

  // Assign positions to metrics based on quartiles with the polarity of the dataset


  data.forEach(entry => {
    const metricValue = entry.metric_value;

    if (datasetPolarity.value === "minimum") {
      if (metricValue <= q1) {
        metricPositions[entry.tool_id] = { quartile: 1, bgColor: 'rgb(237, 248, 233)' };
      } else if (metricValue > q1 && metricValue <= q2) {
        metricPositions[entry.tool_id] = { quartile: 2, bgColor: 'rgb(186, 228, 179)' };
      } else if (metricValue > q2 && metricValue < q3) {
        metricPositions[entry.tool_id] = { quartile: 3, bgColor: 'rgb(116, 196, 118)' };
      } else if (metricValue >= q3) {
        metricPositions[entry.tool_id] = { quartile: 4, bgColor: 'rgb(35, 139, 69)' };
      }
    } else {
      if (metricValue <= q1) {
        metricPositions[entry.tool_id] = { quartile: 4, bgColor: 'rgb(35, 139, 69)' };
      } else if (metricValue > q1 && metricValue <= q2) {
        metricPositions[entry.tool_id] = { quartile: 3, bgColor: 'rgb(116, 196, 118)' };
      } else if (metricValue > q2 && metricValue < q3) {
        metricPositions[entry.tool_id] = { quartile: 2, bgColor: 'rgb(186, 228, 179)' };
      } else if (metricValue >= q3) {
        metricPositions[entry.tool_id] = { quartile: 1, bgColor: 'rgb(237, 248, 233)' };
      }
    }


  });

  return metricPositions;
}


// DOWNLOAD BUTTON
// ----------------------------------------------------------------
async function downloadChart(format) {
  console.log('Downloading chart as', format);
  try {
    if (format === 'pdf') {
      const Plotly = require('plotly.js-dist');
      const pdf = new jsPDF();

      // Get chart image as base64 data URI
      const chartImageURI = await Plotly.toImage(document.getElementById('barPlot'), { format: 'png' });
      const chartHeight = 110;
      const chartWidth = 175;

      pdf.addImage(chartImageURI, 'JPEG', 10, 10, chartWidth, chartHeight, null, 'FAST', 0, 0, { dpi: 600 });

      // Add table as text to the PDF
      pdf.autoTable({
        html: '#idDateTable',
        startY: chartHeight + 20, // Start table below chart with 20mm margin
        theme: 'grid',
        tableWidth: 'auto',
        styles: {
          cellPadding: 1,
          fontSize: 8,
          overflow: 'linebreak'
        },
        margin: { top: 10 }
      });


      // Add additional table if it is visible
      if (showAdditionalTable.value) {
        const columns = ["Tool", "Quartile"]; // Define your columns

        // Extract data from quartileDataArray
        const rows = quartileDataArray.value.map(quartile => [quartile.tool, quartile.quartile.quartile]);

        // Generate autoTable with custom styles
        pdf.autoTable({
          head: [columns],
          body: rows,
          startY: pdf.autoTable.previous.finalY + 10,
          theme: 'grid',
          tableWidth: 'auto',
          styles: {
            cellPadding: 1,
            fontSize: 8,
            overflow: 'linebreak'
          },
          didParseCell: function (cell, rows) {
            if (rows.column.dataKey === 'quartile') {
              cell.styles.halign = 'right';

            }
          }
        });
      }

      // Save the PDF
      pdf.save(`benchmarking_chart_${datasetId.value}.${format}`);

    } else if (format === 'svg') {
      const Plotly = require('plotly.js-dist');
      const chart = document.getElementById('barPlot');
      const options = { format: 'svg', width: 800, height: 600 };

      Plotly.toImage(chart, options)
        .then((svg) => {
          const link = document.createElement('a');
          link.href = 'data:image/svg+xml;base64,' + btoa(svg);
          link.download = `benchmarking_chart_${datasetId.value}.${format}`;
          link.click();
        })
        .catch((error) => {
          console.error(`Error downloading the chart as ${format}`, error);
        });
    } else {
      const toDownloadDiv = document.getElementById('todownload');
      const downloadCanvas = await html2canvas(toDownloadDiv, {
        scrollX: 0,
        scrollY: 0,
        width: toDownloadDiv.offsetWidth,
        height: toDownloadDiv.offsetHeight,
      });
      const downloadImage = downloadCanvas.toDataURL(`image/${format}`);

      const link = document.createElement('a');
      link.href = downloadImage;
      link.download = `benchmarking_chart_${datasetId.value}.${format}`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  } catch (error) {
    console.error('Error downloading chart:', error);
  }
}



// FORMAT DATE
// ----------------------------------------------------------------
function formatDateString(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

</script>
<style scoped>
.butns {
  position: absolute;
  top: 14px;
  margin-top: 10px;
  z-index: 1
}

.plot-container {
  position: relative;
  margin-bottom: 20px;
}


.table-secondary {
  background-color: #6c757d;
  color: white;
}

.tableid {
  font-family: arial, sans-serif;
  width: 100%;
  margin: 15px;
  text-align: center;
}


.tableid th {
  background-color: #6c757d;
  color: white;

}

.tableid td {
  background-color: white;
  color: black;
}

rect {
  cursor: default !important;
}

.table-container {
  max-height: 710px;
  overflow-y: auto;
  margin-top: 100px;
}

.quartile-table-container {
  width: 100%;
  table-layout: fixed;
}

.quartile-table-container th {
  position: sticky;
  top: 0;
  z-index: 1;
}

.quartile-table-container td {
  padding-top: 8px;
  padding-bottom: 8px;
}


@keyframes fadeIn {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes fadeOut {
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
    visibility: hidden;
  }
}

/* Apply animation when table enters and leaves */
.fade-in {
  animation: fadeIn 0.5s ease-in-out;
}

.fade-out {
  animation: fadeOut 0.5s ease-in-out;
}

/* Ensure table headers are affected by animation */
.fade-out table th,
.fade-out table td {
  opacity: 0;
}

/* Hide borders of table headers during fade-out */
.fade-out table th {
  border-color: transparent;
}
</style>
